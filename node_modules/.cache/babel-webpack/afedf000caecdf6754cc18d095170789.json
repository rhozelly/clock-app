{"ast":null,"code":"import { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, observeOn, switchMap } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, Pipe, ChangeDetectorRef, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵfetchInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/storage';\nimport { AsyncPipe } from '@angular/common'; // Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction fromTask(task) {\n  return new Observable(subscriber => {\n    const progress = snap => subscriber.next(snap);\n\n    const error = e => subscriber.error(e);\n\n    const complete = () => subscriber.complete(); // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n\n\n    progress(task.snapshot);\n    const unsub = task.on('state_changed', progress); // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n\n    task.then(snapshot => {\n      progress(snapshot);\n      complete();\n    }, e => {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    }); // on's type if Function, rather than () => void, need to wrap\n\n    return function unsubscribe() {\n      unsub();\n    };\n  }).pipe( // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n  // that if the task is already finished we don't emit the old running state\n  debounceTime(0));\n}\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\n\n\nfunction createUploadTask(task) {\n  const inner$ = fromTask(task);\n  return {\n    task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: () => inner$,\n    percentageChanges: () => inner$.pipe(map(s => s.bytesTransferred / s.totalBytes * 100))\n  };\n}\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\n\n\nfunction createStorageRef(ref, schedulers, keepUnstableUntilFirst) {\n  return {\n    getDownloadURL: () => of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => ref.getDownloadURL()), keepUnstableUntilFirst),\n    getMetadata: () => of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => ref.getMetadata()), keepUnstableUntilFirst),\n    delete: () => from(ref.delete()),\n    child: path => createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst),\n    updateMetadata: meta => from(ref.updateMetadata(meta)),\n    put: (data, metadata) => {\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: (data, format, metadata) => {\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll: () => from(ref.listAll())\n  };\n}\n\nconst BUCKET = /*#__PURE__*/new InjectionToken('angularfire2.storageBucket');\nconst MAX_UPLOAD_RETRY_TIME = /*#__PURE__*/new InjectionToken('angularfire2.storage.maxUploadRetryTime');\nconst MAX_OPERATION_RETRY_TIME = /*#__PURE__*/new InjectionToken('angularfire2.storage.maxOperationRetryTime');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n\nlet AngularFireStorage = /*#__PURE__*/(() => {\n  class AngularFireStorage {\n    constructor(options, nameOrConfig, storageBucket, // tslint:disable-next-line:ban-types\n    platformId, zone, maxUploadRetryTime, maxOperationRetryTime) {\n      this.schedulers = new ɵAngularFireSchedulers(zone);\n      this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n      this.storage = ɵfetchInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app, () => {\n        const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n\n        if (maxUploadRetryTime) {\n          storage.setMaxUploadRetryTime(maxUploadRetryTime);\n        }\n\n        if (maxOperationRetryTime) {\n          storage.setMaxOperationRetryTime(maxOperationRetryTime);\n        }\n\n        return storage;\n      }, [maxUploadRetryTime, maxOperationRetryTime]);\n    }\n\n    ref(path) {\n      return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n    }\n\n    refFromURL(path) {\n      return createStorageRef(this.storage.refFromURL(path), this.schedulers, this.keepUnstableUntilFirst);\n    }\n\n    upload(path, data, metadata) {\n      const storageRef = this.storage.ref(path);\n      const ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n      return ref.put(data, metadata);\n    }\n\n  }\n\n  AngularFireStorage.ɵfac = function AngularFireStorage_Factory(t) {\n    return new (t || AngularFireStorage)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(BUCKET, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), ɵngcc0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFireStorage.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AngularFireStorage_Factory() {\n      return new AngularFireStorage(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(BUCKET, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), i0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8));\n    },\n    token: AngularFireStorage,\n    providedIn: \"any\"\n  });\n  /** @nocollapse */\n\n  return AngularFireStorage;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** to be used with in combination with | async */\n\n\nlet GetDownloadURLPipe = /*#__PURE__*/(() => {\n  class GetDownloadURLPipe {\n    constructor(storage, cdr) {\n      this.storage = storage;\n      this.asyncPipe = new AsyncPipe(cdr);\n    }\n\n    transform(path) {\n      if (path !== this.path) {\n        this.path = path;\n        this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n      }\n\n      return this.asyncPipe.transform(this.downloadUrl$);\n    }\n\n    ngOnDestroy() {\n      this.asyncPipe.ngOnDestroy();\n    }\n\n  }\n\n  GetDownloadURLPipe.ɵfac = function GetDownloadURLPipe_Factory(t) {\n    return new (t || GetDownloadURLPipe)(ɵngcc0.ɵɵdirectiveInject(AngularFireStorage, 16), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef, 16));\n  };\n\n  GetDownloadURLPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"getDownloadURL\",\n    type: GetDownloadURLPipe,\n    pure: false\n  });\n  /** @nocollapse */\n\n  return GetDownloadURLPipe;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GetDownloadURLPipeModule = /*#__PURE__*/(() => {\n  class GetDownloadURLPipeModule {}\n\n  GetDownloadURLPipeModule.ɵfac = function GetDownloadURLPipeModule_Factory(t) {\n    return new (t || GetDownloadURLPipeModule)();\n  };\n\n  GetDownloadURLPipeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: GetDownloadURLPipeModule\n  });\n  GetDownloadURLPipeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return GetDownloadURLPipeModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GetDownloadURLPipeModule, {\n    declarations: [GetDownloadURLPipe],\n    exports: [GetDownloadURLPipe]\n  });\n})();\n\nlet AngularFireStorageModule = /*#__PURE__*/(() => {\n  class AngularFireStorageModule {}\n\n  AngularFireStorageModule.ɵfac = function AngularFireStorageModule_Factory(t) {\n    return new (t || AngularFireStorageModule)();\n  };\n\n  AngularFireStorageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireStorageModule\n  });\n  AngularFireStorageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireStorage],\n    imports: [GetDownloadURLPipeModule]\n  });\n  return AngularFireStorageModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AngularFireStorageModule, {\n    exports: [GetDownloadURLPipeModule]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, createStorageRef, createUploadTask, fromTask }; //# sourceMappingURL=angular-fire-storage.js.map","map":null,"metadata":{},"sourceType":"module"}